<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Discompress â€” Under 10MB for Discord</title>
<meta name="description" content="Upload a video. Get it back under 10MB. Perfect for avoiding Discord Nitro fees.">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- Clean, non-generic display font -->
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0b12; --text:#eaf2ff; --muted:#cfe3ff; /* more contrast */
    --a:#27f1ff; --b:#ff4df0;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text); font:500 16px/1.5 "Space Grotesk",system-ui,Segoe UI,Inter,Roboto;
    /* flowing ambient dark gradient */
    background:
      radial-gradient(1200px 700px at 92% -10%, #1b1b33 0%, transparent 60%),
      radial-gradient(900px 600px at -10% 110%, #17172c 0%, transparent 60%),
      conic-gradient(from 0deg at 60% 40%, #12122a, #0e1020, #17112a, #0e1020, #12122a);
    animation:bgShift 18s linear infinite;
    display:grid; place-items:center; padding:40px;
  }
  @keyframes bgShift{0%{background-position:0 0,0 0,0 0}50%{background-position:8% -6%,-6% 10%,120px 60px}100%{background-position:0 0,0 0,0 0}}

  .wrap{max-width:920px; width:min(92vw,920px); text-align:center}
  h1{margin:0 0 10px; font-weight:700; font-size:clamp(28px,6vw,48px); letter-spacing:.2px; text-shadow:0 2px 20px #0007}
  .sub{margin:0 auto 28px; color:#a7b6d1; max-width:640px; font-size:clamp(14px,2.8vw,18px)}

  /* BIG glass+neon button */
  #pick{
    position:relative; display:inline-block; border:0; cursor:pointer; user-select:none;
    padding:clamp(18px,3.8vw,30px) clamp(34px,7vw,70px);
    border-radius:22px; font-weight:700; font-size:clamp(18px,4vw,26px); letter-spacing:.4px;
    color:#eef6ff; background:transparent; isolation:isolate; transform:translateZ(0);
    transition:transform .18s ease, filter .35s ease;
  }
  #pick:hover{ transform:translateY(-4px) scale(1.02);
    filter:drop-shadow(0 0 40px rgba(39,241,255,.4)) drop-shadow(0 0 40px rgba(255,77,240,.3)) }
  #pick:active{ transform:translateY(1px) scale(.985) }

  /* neon rim */
  #pick::before{
    content:""; position:absolute; inset:0; border-radius:22px; padding:3px;
    background:linear-gradient(135deg,var(--a),var(--b));
    -webkit-mask:linear-gradient(#000 0 0) content-box,linear-gradient(#000 0 0);
    -webkit-mask-composite:xor; mask-composite:exclude; z-index:-1;
    filter:drop-shadow(0 0 38px rgba(39,241,255,.35)) drop-shadow(0 0 34px rgba(255,77,240,.28));
  }
  /* glass interior */
  #pick::after{
    content:""; position:absolute; inset:5px; border-radius:17px;
    background:
      linear-gradient(135deg, rgba(255,255,255,.10), rgba(255,255,255,.03)),
      radial-gradient(120% 200% at 0% 0%, rgba(39,241,255,.28), transparent 60%),
      radial-gradient(120% 200% at 100% 100%, rgba(255,77,240,.28), transparent 60%),
      #131433dd;
    backdrop-filter: blur(10px);
    z-index:-1;
  }
  /* shine sweep */
  #pick .shine{pointer-events:none; position:absolute; inset:5px; border-radius:17px; overflow:hidden}
  #pick .shine::before{content:""; position:absolute; top:0; left:-150%; width:40%; height:100%;
    background:linear-gradient(90deg,transparent,rgba(255,255,255,.33),transparent); transform:skewX(-20deg)}
  #pick:hover .shine::before{ animation:shine 1.1s ease }
  @keyframes shine{0%{left:-150%}100%{left:150%}}

  /* Progress (hidden by default, fades in/out) */
  .progress{ width:min(760px,92vw); margin:18px auto 0; opacity:0; transform:translateY(8px);
    transition:opacity .35s ease, transform .35s ease }
  .progress.show{ opacity:1; transform:translateY(0) }
  .bar{width:100%; height:12px; background:#1e2035; border-radius:999px; overflow:hidden}
  .fill{width:0%; height:100%; background:linear-gradient(90deg,var(--a),var(--b)); transition:width .09s linear}
  .eta{margin-top:6px; font-size:12px; color:var(--muted)}

  /* Hidden input */
  #file{display:none}
  @media (max-width:520px){ .wrap{padding:0 4px} }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Discompress</h1>
    <p class="sub">Upload a video. Get it back under <b>10&nbsp;MB</b>. Perfect for sharing your videos on Discord without having your creativity blocked by a Nitro subscription.</p>

    <input id="file" type="file" accept="video/*">
    <button id="pick">Upload Video<span class="shine" aria-hidden="true"></span></button>

    <div id="progress" class="progress" aria-hidden="true">
      <div class="bar"><div id="fill" class="fill"></div></div>
      <div id="eta" class="eta"></div>
    </div>
  </div>

<script>
  // ðŸ”— BACKEND (Render)
  const RENDER_URL = 'https://discompress.onrender.com'; // <-- set yours
  const API = RENDER_URL + '/api/upload';
  const HEALTH = RENDER_URL + '/health';

  const pick = document.getElementById('pick');
  const file = document.getElementById('file');
  const progress = document.getElementById('progress');
  const fill = document.getElementById('fill');
  const etaEl = document.getElementById('eta');

  // Debug overlay (Ctrl + D)
  const dbg = (()=>{
    const box = document.createElement('pre');
    box.style.cssText = 'position:fixed;bottom:14px;left:14px;max-width:min(92vw,680px);max-height:46vh;overflow:auto;margin:0;'
      +'padding:10px 12px;background:#0b0b12e6;border:1px solid #232343;border-radius:10px;color:#cfe3ff;font:12px/1.35 ui-monospace,Consolas,Menlo;'
      +'box-shadow:0 8px 30px rgba(0,0,0,.4);display:none;white-space:pre-wrap;';
    document.body.appendChild(box);
    function log(...a){ box.textContent += a.join(' ') + '\n'; box.scrollTop = box.scrollHeight; }
    function toggle(){ box.style.display = (box.style.display==='none'?'block':'none'); }
    window.addEventListener('keydown', (e)=>{ if(e.ctrlKey && (e.key==='d'||e.key==='D')) { e.preventDefault(); toggle(); } });
    return {log,toggle};
  })();

  // health ping (helps confirm backend reachable)
  fetch(HEALTH).then(r=>dbg.log('health:', r.status)).catch(e=>dbg.log('health error:', e.message));

  pick.addEventListener('click', ()=> file.click());
  file.addEventListener('change', ()=> {
    const f = file.files && file.files[0];
    if (f) startUpload(f);
  });

  function showProgress(show){
    progress.classList.toggle('show', !!show);
    etaEl.textContent = '';
  }
  function setProgress(p){ fill.style.width = Math.max(0, Math.min(100, p)) + '%'; }

  // ETA heuristic: base + per-MB on free CPU; extends automatically if needed
  function estimateSeconds(file){
    const MB = file.size / (1024*1024);
    return Math.max(30, Math.round(20 + 2.2 * MB)); // tweakable
  }
  const formatS = (s)=>{
    s = Math.max(0, Math.round(s));
    const m = Math.floor(s/60), ss = s%60;
    return (m>0? m+':' : '') + (m>0? String(ss).padStart(2,'0') : ss) + 's';
  };

  function startUpload(f){
    setProgress(0); showProgress(true);
    pick.disabled = true; pick.style.opacity = .85;

    const form = new FormData(); form.append('video', f);
    const xhr = new XMLHttpRequest(); xhr.open('POST', API, true); xhr.responseType = 'blob';

    // drive upload 0..80
    xhr.upload.onprogress = (e)=>{
      if (!e.lengthComputable) return;
      const upPct = (e.loaded / e.total) * 80;
      setProgress(Math.round(upPct));
    };

    // start processing animation IMMEDIATELY when upload finishes
    let procTimer=null, procStart=0, eta=0, p=80, processing=false;
    xhr.upload.addEventListener('load', ()=>{
      // upload finished locally; server is now processing
      if (processing) return;
      processing = true;
      dbg.log('upload complete; processingâ€¦');
      startProcessing(f);
    });

    // also start if headers arrive first (edge case)
    xhr.onreadystatechange = ()=>{
      if (xhr.readyState === 2 && !processing){
        processing = true;
        dbg.log('server accepted; processingâ€¦');
        startProcessing(f);
      }
      if (xhr.readyState === 4){
        stopProcessing();
        dbg.log('done state:', xhr.status);
        if (xhr.status === 200){
          setProgress(100); etaEl.textContent = '';
          const blob = xhr.response;
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = 'discompress_video.mp4'; a.click();
          URL.revokeObjectURL(url);
          setTimeout(()=>{ showProgress(false); setProgress(0); }, 700);
        } else {
          try { const r = new FileReader(); r.onload = ()=> dbg.log('error body:', r.result || '(no text)'); r.readAsText(xhr.response); } catch(_){}
          const old = fill.style.background;
          fill.style.transition='none'; fill.style.width='100%'; fill.style.background='#ff5c80';
          setTimeout(()=>{ fill.style.transition='width .09s linear'; fill.style.background=old; showProgress(false); setProgress(0); }, 1100);
          etaEl.textContent = '';
        }
        pick.disabled = false; pick.style.opacity = 1; file.value='';
      }
    };

    xhr.onerror = ()=>{
      stopProcessing(); dbg.log('network error');
      showProgress(false); setProgress(0); pick.disabled=false; pick.style.opacity=1; file.value='';
    };
    xhr.send(form);

    function startProcessing(file){
      p = Math.max(parseInt(fill.style.width) || 80, 80);
      procStart = performance.now();
      eta = estimateSeconds(file);
      renderEta(); // first render

      clearInterval(procTimer);
      procTimer = setInterval(()=>{
        const elapsed = (performance.now() - procStart)/1000;
        if (elapsed > eta) { eta = Math.ceil(eta * 1.2); } // extend if we overrun
        const target = 80 + Math.min(0.99, elapsed/eta)*19; // map 0..eta -> 80..99
        // ease toward target
        p += Math.max(0.1, (target - p) * 0.08);
        if (p > 99) p = 99;
        setProgress(p);
        renderEta();
      }, 150);
    }
    function stopProcessing(){ clearInterval(procTimer); procTimer=null; }
    function renderEta(){
      const elapsed = procStart ? (performance.now() - procStart)/1000 : 0;
      const remain = Math.max(0, Math.round(eta - elapsed));
      etaEl.textContent = remain ? `~${formatS(remain)} remaining` : '';
    }
  }
</script>
</body>
</html>
